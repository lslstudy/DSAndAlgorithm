select、poll、epoll的区别

select
select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。
select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，
可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。
缺点：
    每次调用select都需要把文件描述符（FD）从用户态拷贝到内核，开销比较大
    每次都需要在内核遍历传入的文件描述符（FD）
    select支持文件数量比较小，默认是1024。当然，也可以通过修改宏定义改掉，但这会造成效率的降低。

poll
poll及轮训，poll和select本质上是一样的，只是描述fd集合的方式不同。poll使用的是pollfd结构，
select使用的是fd_set结构。

epoll
epoll是对select和poll的改进，而且改正了select、poll的三个缺点和不足。
相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，
将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
优点：
    每次注册新事件到epoll句柄都会把所有的fd拷贝进来，而不是在epoll_wait中重复拷贝，这样确保fd只会被拷贝一次
    epoll不是像select/poll那样每次都把fd加入等待队列，epoll把每个fd指定一个回调函数，
    当设备就绪时，唤醒等待队列的等待者就会调用其它的回调函数，这个回调函数会把就绪的fd放入一个就绪链表。
    epoll_wait就是在这个就绪链表中查看有没有就绪fd。epoll没有fd数目限制
缺点：
    如果没有大量的idle-connection或者dead-connection，
    epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，
    就会发现epoll的效率大大高于select/poll。



select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。
而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，
但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。
虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，
而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，
而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，
注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列）。这也能节省不少的开销。

tornado.utils.Configurable: 配置类，是工厂模式的实现，通过使用构造函数（new()）作为工厂方法。
其子类必须实现configurable_base()、configurable_default()、initialize()。
通过调用configure()函数去配置当基类（不是指Configurable，而是继承至Configurable的类，
如tornado.ioloop.IOLoop）被实例化时使用的实现类，以及配置其实现类初始化的关键字参数。

tornado 内部状态吗：
    404:    请求路径无法匹配任何requesthandler类对应的模式返回404
    400:    没有传递需要给的的参数返回400
    405:    没有定义的方法,请求的方法不对
    500:    遇到任何不能让其退出的错误或者代码里面没有捕捉的异常返回500
    200:    成功响应请求的标志.

重写错误信息：重写RequestHandler中的write_error方法
    def write_error(self. status_code, **kwargs):
        pass

tornado 异步

tornado.httpclient.HTTPClient

@tornado.web.asynchronous
tornado.httpclient.AsyncHTTPClient() -> fetch(callback=self.method_name)

异步装饰器和finish方法
@tornado.web.asynchronous 作用：tornado默认在函数返回时关闭客户端的连接，
    但是在处理回调函数的异步请求时，需要保持开启状态直到回调函数执行完毕，作用就是保持客户端的连接状态

finish方法作用: 在使用@tornado.web.asynchornous装饰器时，tornado不会关闭客户端的连接，必须显示调用
    finish方法告诉tornado关闭连接.

异步生成器(tornado.gen模块):
     example:

     @tornado.web.asynchronous
     @tornado.gen.engine
     def get(self):
        client = tornado.httpclient.AsyncHTTPClient()
        response = yield tornado.gen.Task(client.fetch, urls+params)
        ...
        self.write("xxx")
        self.finish()


tornado ioloop 和 iostream
    ioloop.py: 主要的是将底层的epoll或者说是其他的IO多路复用封装作异步事件来处理。
    iostream.py: 主要是对于下层的异步事件的进一步封装，为其封装了更上一层的buffer（IO）事件。


